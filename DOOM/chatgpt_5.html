<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DOOM (One and done) — Pure HTML/CSS/JS</title>
  <style>
    :root {
      color-scheme: dark;
      --ui: #e2e8f0;
      --ui-dim: #94a3b8;
      --accent: #f59e0b;
      --danger: #ef4444;
      --ok: #22c55e;
      --bg: #0b0e12;
      --panel: #111827cc;
      --glass: rgba(15, 23, 42, 0.6);
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 700px at 50% -10%, #1f2937 0%, #0b0e12 60%, #030712 100%);
      color: var(--ui);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }
    #root {
      position: fixed; inset: 0; display: grid; place-items: center;
    }
    #gameWrapper {
      position: relative;
      width: min(96vw, 1200px);
      aspect-ratio: 16 / 9;
      border-radius: 14px;
      background: linear-gradient(180deg, #000000 0%, #0a0f17 60%, #060a0f 100%);
      box-shadow: 0 30px 80px rgba(0,0,0,.6), inset 0 0 0 1px rgba(255,255,255,.05);
      overflow: hidden;
    }
    canvas#view {
      position: absolute; inset: 0; width: 100%; height: 100%;
      image-rendering: pixelated; image-rendering: crisp-edges;
      cursor: crosshair;
    }
    #hud { position: absolute; inset: 0; pointer-events: none; }
    #hud .bar { position: absolute; left: 16px; right: 16px; bottom: 14px; display: flex; gap: 14px; align-items: end; }
    .chip {
      background: linear-gradient(180deg, rgba(30,41,59,.92), rgba(15,23,42,.92));
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 10px; padding: 10px 12px; pointer-events: none;
      display: inline-flex; align-items: center; gap: 8px; font-weight: 700; letter-spacing: .02em;
      text-shadow: 0 1px 0 rgba(0,0,0,.6);
      backdrop-filter: blur(8px) saturate(1.2);
      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 20px rgba(255,255,255,.02);
    }
    .chip .label { color: var(--ui-dim); font-weight: 600; }
    .chip .value { font-variant-numeric: tabular-nums; min-width: 2ch; text-align: right; }
    .chip.health { border-color: rgba(239,68,68,.35); }
    .chip.health .value { color: var(--danger); }
    .chip.ammo { border-color: rgba(245,158,11,.4); }
    .chip.ammo .value { color: var(--accent); }
    .chip.score { border-color: rgba(34,197,94,.35); }
    .chip.score .value { color: var(--ok); }

    #topLeft { position: absolute; left: 12px; top: 12px; display: flex; gap: 10px; align-items: center; }
    #fps { font-variant-numeric: tabular-nums; opacity: .7; }
    #minimap {
      width: 170px; height: 170px; border-radius: 12px; overflow: hidden; border: 1px solid rgba(255,255,255,.08); background: rgba(2,6,23,.5);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }

    #overlay {
      position: absolute; inset: 0; display: grid; place-items: center; background: linear-gradient(180deg, rgba(2,6,23,.85), rgba(2,6,23,.65));
      backdrop-filter: blur(6px) saturate(1.2);
    }
    #panel {
      width: min(92%, 840px);
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(17,24,39,.9), rgba(2,6,23,.9));
      border: 1px solid rgba(148,163,184,.25);
      box-shadow: 0 30px 120px rgba(0,0,0,.6), inset 0 0 0 1px rgba(255,255,255,.02);
      padding: 22px 22px 18px 22px;
    }
    #title { display: flex; align-items: center; gap: 14px; }
    #title h1 { margin: 0; font-size: clamp(22px, 3.2vw, 36px); letter-spacing: .06em; }
    #title svg { filter: drop-shadow(0 4px 20px rgba(245,158,11,.5)); }
    #panel .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; margin-top: 12px; }
    #panel .card { border: 1px solid rgba(148,163,184,.2); border-radius: 12px; padding: 14px; background: linear-gradient(180deg, rgba(30,41,59,.55), rgba(2,6,23,.65)); }
    #panel h3 { margin: 0 0 8px 0; font-size: 13px; letter-spacing: .12em; color: var(--ui-dim); }
    #panel ul { margin: 0; padding-left: 16px; display: grid; gap: 6px; }
    #panel li { opacity: .95; }
    #panel .actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 12px; }
    button {
      appearance: none; border: 1px solid rgba(148,163,184,.35); color: var(--ui); background: linear-gradient(180deg,#0b1220,#0a0f17);
      border-radius: 12px; padding: 10px 14px; font-weight: 700; letter-spacing: .08em; cursor: pointer; transition: transform .08s ease, filter .08s ease, box-shadow .2s ease;
      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.05);
    }
    button.primary { border-color: rgba(245,158,11,.6); color: #fff; background: linear-gradient(180deg,#7c3aed,#6d28d9); box-shadow: 0 12px 40px rgba(124,58,237,.35); }
    button:active { transform: translateY(1px); filter: brightness(.95); }
    #msg { text-align: center; color: var(--ui-dim); margin-top: 8px; font-size: 12px; }

    #crosshair { position: absolute; inset: 0; pointer-events: none; display: grid; place-items: center; opacity: .8; }
    #crosshair svg { width: 36px; height: 36px; filter: drop-shadow(0 0 3px rgba(255,255,255,.18)); }

    #toast { position: absolute; right: 14px; top: 14px; display: grid; gap: 8px; }
    .toast-item { background: rgba(2,6,23,.85); border: 1px solid rgba(148,163,184,.25); padding: 8px 12px; border-radius: 10px; font-size: 12px; opacity: .95; }

    @media (max-width: 720px) { #panel .grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div id="root">
    <div id="gameWrapper">
      <canvas id="view" width="960" height="540"></canvas>
      <div id="hud">
        <div id="topLeft">
          <canvas id="minimap" width="170" height="170"></canvas>
          <div class="chip"><span class="label">FPS</span><span id="fps" class="value">0</span></div>
        </div>
        <div class="bar">
          <div class="chip health"><span class="label">HEALTH</span><span id="health" class="value">100</span></div>
          <div class="chip ammo"><span class="label">AMMO</span><span id="ammo" class="value">50</span></div>
          <div class="chip score"><span class="label">SCORE</span><span id="score" class="value">0</span></div>
        </div>
      </div>
      <div id="crosshair" aria-hidden="true">
        <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="32" cy="32" r="8" stroke="#e5e7eb" stroke-opacity=".7" stroke-width="2"></circle>
          <circle cx="32" cy="32" r="1.5" fill="#e5e7eb"></circle>
          <path d="M32 2v10M32 52v10M2 32h10M52 32h10" stroke="#e5e7eb" stroke-opacity=".55" stroke-linecap="round" stroke-width="3"/>
        </svg>
      </div>
      <div id="overlay">
        <div id="panel">
          <div id="title">
            <svg width="48" height="48" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <linearGradient id="g1" x1="0" y1="0" x2="0" y2="1">
                  <stop offset="0" stop-color="#fde68a"/>
                  <stop offset="1" stop-color="#f59e0b"/>
                </linearGradient>
              </defs>
              <path d="M8 8h16l4 8h8l4-8h16v48H8z" fill="url(#g1)" stroke="#fde68a" stroke-width="1"/>
              <path d="M12 20h40v28H12z" fill="#0b1220" opacity=".45"/>
            </svg>
            <h1>DOOM-like — One and done</h1>
          </div>
          <div class="grid">
            <div class="card">
              <h3>CONTROLS</h3>
              <ul>
                <li>W/A/S/D: Move & strafe</li>
                <li>Arrow Left/Right or Mouse: Turn</li>
                <li>Click or Space: Fire</li>
                <li>E: Open doors</li>
                <li>P: Pause • R: Restart</li>
              </ul>
            </div>
            <div class="card">
              <h3>OBJECTIVE</h3>
              <ul>
                <li>Explore, eliminate enemies, survive</li>
                <li>Pick up ammo and medkits</li>
                <li>Doors require proximity</li>
              </ul>
            </div>
          </div>
          <div class="actions">
            <button id="btnStart" class="primary">Click to Start</button>
            <button id="btnNoMouse">Start (No Mouse)</button>
          </div>
          <div id="msg">No downloads. Pure HTML/CSS/JS — rendered with classic raycasting.</div>
        </div>
      </div>
      <div id="toast"></div>
    </div>
  </div>

  <script>
  // High-level game configuration
  const CONFIG = {
    canvasWidth: 960,
    canvasHeight: 540,
    fovDegrees: 66,
    moveSpeed: 3.2, // units per second
    strafeSpeed: 2.8,
    rotSpeed: 2.8, // radians per second
    renderResolutionScale: 1.0, // 1.0 = full width rays; 0.5 = half columns for speed
    maxEnemies: 10,
    maxProjectDistance: 20, // ray distance for hitscan
    doorOpenTime: 3.0,
  };

  // Utility helpers
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const TAU = Math.PI * 2;
  const deg2rad = d => d * Math.PI / 180;
  const rand = (a=0, b=1) => a + Math.random() * (b - a);
  const nowSec = () => performance.now() / 1000;

  // Audio (synth only, no external assets)
  class SFX {
    constructor() {
      const AC = window.AudioContext || window.webkitAudioContext;
      this.ctx = new AC();
      this.master = this.ctx.createGain();
      this.master.gain.value = 0.2;
      this.master.connect(this.ctx.destination);
    }
    tone(freq=220, dur=0.1, type='square', vol=0.5) {
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type; o.frequency.setValueAtTime(freq, this.ctx.currentTime);
      g.gain.value = 0; g.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + dur);
      o.connect(g).connect(this.master);
      o.start(); o.stop(this.ctx.currentTime + dur + 0.02);
    }
    noise(dur=0.08, vol=0.5) {
      const bufferSize = this.ctx.sampleRate * dur;
      const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * (1 - i/bufferSize);
      const src = this.ctx.createBufferSource(); src.buffer = buffer;
      const g = this.ctx.createGain(); g.gain.value = vol; g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + dur);
      src.connect(g).connect(this.master); src.start();
    }
    shoot() { this.noise(0.08, 0.4); this.tone(120, 0.07, 'square', 0.35); }
    hit() { this.tone(90, 0.06, 'sawtooth', 0.3); }
    hurt() { this.tone(160, 0.12, 'triangle', 0.25); }
    pickup() { this.tone(660, 0.04, 'square', 0.18); this.tone(880, 0.06, 'square', 0.18); }
    door() { this.tone(220, 0.12, 'sawtooth', 0.25); }
  }
  const sfx = new SFX();

  // Map and textures
  const MAP_W = 24, MAP_H = 24;
  // 0 empty; 1 brick; 2 tech; 3 hazard; 4 door; 5 metal
  const map = [
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,5,0,5,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,5,3,5,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,5,3,5,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,5,3,5,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,4,4,4,0,0,0,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,4,0,4,0,0,0,0,0,0,0,0,0,0,0,5,1,
    1,0,0,0,0,0,0,0,4,0,4,0,0,0,0,0,0,2,2,2,2,0,5,1,
    1,0,0,0,0,0,0,0,4,0,4,0,0,0,0,0,0,0,0,0,2,0,5,1,
    1,0,0,0,0,0,0,0,4,0,4,0,0,0,0,0,0,0,0,0,2,0,5,1,
    1,0,0,0,0,0,0,0,4,4,4,0,0,0,0,0,0,3,3,3,3,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,5,1,
    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,5,1,
    1,5,5,5,5,5,5,5,5,5,0,0,0,0,0,0,0,0,0,0,3,0,5,1,
    1,5,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,3,0,5,1,
    1,5,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,3,0,5,1,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  ];
  const mapAt = (x,y) => (x<0||y<0||x>=MAP_W||y>=MAP_H) ? 1 : map[y*MAP_W + x];
  const isWall = (tile) => tile === 1 || tile === 2 || tile === 3 || tile === 5 || tile === 4;
  const isDoor = (tile) => tile === 4;

  // Door state tracking
  const doors = new Map(); // key "x,y" -> {open:0..1, lastUseTime}
  const doorState = (x,y) => {
    const k = `${x},${y}`;
    if (!doors.has(k)) doors.set(k, { open: 0, lastUseTime: -999 });
    return doors.get(k);
  };

  // Textures: build small 64x64 procedural canvases per wall type
  const TEX_SIZE = 64;
  const textures = {};
  function makeTexture(draw) {
    const c = document.createElement('canvas'); c.width = c.height = TEX_SIZE; const g = c.getContext('2d');
    draw(g);
    return c;
  }
  function shade(ctx, amount) {
    ctx.fillStyle = `rgba(0,0,0,${amount})`;
    ctx.fillRect(0,0,TEX_SIZE,TEX_SIZE);
  }
  textures[1] = makeTexture(g => {
    // Brick
    g.fillStyle = '#7f1d1d'; g.fillRect(0,0,TEX_SIZE,TEX_SIZE);
    g.fillStyle = '#b91c1c';
    for (let y=0;y<TEX_SIZE;y+=16) {
      for (let x= (y%32===0?0:8); x<TEX_SIZE; x+=16) {
        g.fillRect(x+1,y+1,14,14);
      }
    }
    g.strokeStyle = 'rgba(0,0,0,.35)';
    for (let y=0;y<=TEX_SIZE;y+=16) { g.beginPath(); g.moveTo(0,y+.5); g.lineTo(TEX_SIZE,y+.5); g.stroke(); }
    for (let y=0;y<TEX_SIZE;y+=16) { for (let x=(y%32===0?0:8); x<=TEX_SIZE; x+=16) { g.beginPath(); g.moveTo(x+.5,y+.5); g.lineTo(x+.5,y+16.5); g.stroke(); } }
    shade(g,.05);
  });
  textures[2] = makeTexture(g => {
    // Tech wall
    const grad = g.createLinearGradient(0,0,0,TEX_SIZE);
    grad.addColorStop(0,'#9ca3af'); grad.addColorStop(1,'#4b5563'); g.fillStyle = grad; g.fillRect(0,0,TEX_SIZE,TEX_SIZE);
    g.fillStyle = 'rgba(0,0,0,.25)';
    for (let x=0;x<TEX_SIZE;x+=8) g.fillRect(x,0,2,TEX_SIZE);
    g.fillStyle = 'rgba(255,255,255,.08)';
    for (let y=6;y<TEX_SIZE;y+=12) g.fillRect(0,y,TEX_SIZE,2);
    shade(g,.08);
  });
  textures[3] = makeTexture(g => {
    // Hazard stripes
    g.fillStyle = '#f59e0b'; g.fillRect(0,0,TEX_SIZE,TEX_SIZE);
    g.strokeStyle = '#0b0e12'; g.lineWidth = 10;
    for (let i=-TEX_SIZE;i<TEX_SIZE*2;i+=18) { g.beginPath(); g.moveTo(i, -10); g.lineTo(i+TEX_SIZE, TEX_SIZE+10); g.stroke(); }
    shade(g,.06);
  });
  textures[4] = makeTexture(g => {
    // Door
    g.fillStyle = '#6b4f2a'; g.fillRect(0,0,TEX_SIZE,TEX_SIZE);
    g.fillStyle = '#8b6b3c'; g.fillRect(6,6,TEX_SIZE-12,TEX_SIZE-12);
    g.fillStyle = '#46351a'; for (let y=8;y<TEX_SIZE-8;y+=18) g.fillRect(8,y,TEX_SIZE-16,10);
    shade(g,.08);
  });
  textures[5] = makeTexture(g => {
    // Metal plates
    const grad = g.createLinearGradient(0,0,0,TEX_SIZE); grad.addColorStop(0,'#6b7280'); grad.addColorStop(1,'#374151');
    g.fillStyle = grad; g.fillRect(0,0,TEX_SIZE,TEX_SIZE);
    g.fillStyle = 'rgba(255,255,255,.08)'; for (let y=0;y<TEX_SIZE;y+=16) g.fillRect(0,y,TEX_SIZE,2);
    g.fillStyle = 'rgba(0,0,0,.25)'; for (let x=0;x<TEX_SIZE;x+=16) g.fillRect(x,0,2,TEX_SIZE);
    g.fillStyle = '#9ca3af'; for (let y=8;y<TEX_SIZE;y+=16) for (let x=8;x<TEX_SIZE;x+=16) { g.beginPath(); g.arc(x,y,2,0,TAU); g.fill(); }
    shade(g,.06);
  });

  // Sprite atlas (procedural): enemy, ammo, medkit, muzzle flash, weapon
  function makeSprite(size, draw) { const c = document.createElement('canvas'); c.width=c.height=size; const g=c.getContext('2d'); draw(g,size); return c; }
  const SPR = {};
  SPR.enemy = makeSprite(64, (g,s)=>{
    g.fillStyle = '#1f2937'; g.fillRect(0,0,s,s);
    // Red demon style silhouette
    const r = s/2; g.translate(r,r);
    g.fillStyle = '#ef4444';
    g.beginPath(); g.arc(0,8,r*0.6,0,TAU); g.fill();
    g.fillRect(-r*0.5,-r*0.2,r, r*0.9);
    g.fillStyle = '#fff'; g.fillRect(-10,8,6,6); g.fillRect(4,8,6,6);
  });
  SPR.ammo = makeSprite(48, (g,s)=>{ g.fillStyle = '#1f2937'; g.fillRect(0,0,s,s); g.fillStyle = '#f59e0b'; g.fillRect(8,8,s-16,s-16); g.fillStyle='#111827'; g.fillRect(12,18,s-24,8); });
  SPR.medkit = makeSprite(48, (g,s)=>{ g.fillStyle='#1f2937'; g.fillRect(0,0,s,s); g.fillStyle='#e5e7eb'; g.fillRect(6,6,s-12,s-12); g.fillStyle='#ef4444'; g.fillRect(s/2-6,14,12,s-28); g.fillRect(14,s/2-6,s-28,12); });
  SPR.flash = makeSprite(64, (g,s)=>{ const grd=g.createRadialGradient(s/2,s/2,0,s/2,s/2,s/2); grd.addColorStop(0,'rgba(255,255,200,.9)'); grd.addColorStop(.5,'rgba(255,200,0,.5)'); grd.addColorStop(1,'rgba(255,255,255,0)'); g.fillStyle=grd; g.fillRect(0,0,s,s); });
  SPR.weapon = makeSprite(256, (g,s)=>{
    // Transparent background; draw only gun elements
    const c = s/2;
    g.fillStyle='#6b7280'; g.fillRect(c-30, s-110, 60, 110);
    g.fillStyle='#9ca3af'; g.fillRect(c-22, s-125, 44, 48);
    g.fillStyle='#e5e7eb'; g.fillRect(c-10, s-136, 20, 24);
    g.fillStyle='#0ea5e9'; g.fillRect(c-6, s-146, 12, 18);
    const grad=g.createRadialGradient(c, s-8, 4, c, s-6, 40);
    grad.addColorStop(0,'rgba(0,0,0,0.25)'); grad.addColorStop(1,'rgba(0,0,0,0)');
    g.fillStyle=grad; g.beginPath(); g.arc(c, s-6, 40, 0, TAU); g.fill();
  });

  // Player and entities
  const player = {
    x: 3.5,
    y: 3.5,
    dirX: 1,
    dirY: 0,
    planeX: 0,
    planeY: Math.tan(deg2rad(CONFIG.fovDegrees)/2),
    health: 100,
    ammo: 50,
    score: 0,
    alive: true,
    fireCooldown: 0,
  };

  const entities = [];
  const ENTITY_TYPES = {
    ENEMY: 'enemy',
    AMMO: 'ammo',
    MEDKIT: 'medkit',
  };
  function spawn(type, x, y) {
    if (type === ENTITY_TYPES.ENEMY) {
      entities.push({ type, x, y, radius: 0.3, health: 40, state: 'idle', t: 0, hurtTimer: 0 });
    } else if (type === ENTITY_TYPES.AMMO) {
      entities.push({ type, x, y, radius: 0.25 });
    } else if (type === ENTITY_TYPES.MEDKIT) {
      entities.push({ type, x, y, radius: 0.25 });
    }
  }
  // Initial spawns
  spawn(ENTITY_TYPES.ENEMY, 10.5, 10.5);
  spawn(ENTITY_TYPES.ENEMY, 14.5, 12.5);
  spawn(ENTITY_TYPES.ENEMY, 18.2, 17.8);
  spawn(ENTITY_TYPES.AMMO, 5.5, 5.5);
  spawn(ENTITY_TYPES.MEDKIT, 7.2, 5.5);
  spawn(ENTITY_TYPES.ENEMY, 9.5, 20.2);
  spawn(ENTITY_TYPES.AMMO, 12.5, 15.2);
  spawn(ENTITY_TYPES.MEDKIT, 20.5, 16.5);

  // Canvas and contexts
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');
  const mini = document.getElementById('minimap');
  const gmini = mini.getContext('2d');

  // Controls
  const keys = new Set();
  let mouseActive = false; let mouseDeltaX = 0;
  function hookControls(enableMouse) {
    window.addEventListener('keydown', e => { if (e.repeat) return; keys.add(e.key.toLowerCase()); });
    window.addEventListener('keyup', e => { keys.delete(e.key.toLowerCase()); });
    if (enableMouse) {
      canvas.requestPointerLock = canvas.requestPointerLock || canvas.webkitRequestPointerLock;
      document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock;
      canvas.addEventListener('click', ()=>{ if (!mouseActive) { canvas.requestPointerLock(); } });
      document.addEventListener('pointerlockchange', ()=>{ mouseActive = document.pointerLockElement === canvas; });
      document.addEventListener('mousemove', e => { if (mouseActive) mouseDeltaX += e.movementX || 0; });
    }
  }

  // UI elements
  const ui = {
    overlay: document.getElementById('overlay'),
    btnStart: document.getElementById('btnStart'),
    btnNoMouse: document.getElementById('btnNoMouse'),
    fps: document.getElementById('fps'),
    health: document.getElementById('health'),
    ammo: document.getElementById('ammo'),
    score: document.getElementById('score'),
    toast: document.getElementById('toast'),
  };
  function showToast(text, dur=2.0) {
    const d = document.createElement('div'); d.className='toast-item'; d.textContent = text; ui.toast.appendChild(d);
    setTimeout(()=>{ d.style.transition='opacity .3s ease, transform .3s ease'; d.style.opacity='0'; d.style.transform='translateY(-4px)'; setTimeout(()=>d.remove(), 350); }, dur*1000);
  }

  // Game state
  let lastTime = nowSec();
  let paused = false;
  let gameStarted = false;
  let muzzleFlashTimer = 0;
  let zBuffer = new Float32Array(CONFIG.canvasWidth);

  // Raycasting render
  function renderWalls() {
    const width = canvas.width, height = canvas.height;
    ctx.clearRect(0,0,width,height);

    // Sky and floor gradients
    const sky = ctx.createLinearGradient(0,0,0,height/2);
    sky.addColorStop(0,'#0a0f17'); sky.addColorStop(1,'#111827');
    ctx.fillStyle = sky; ctx.fillRect(0,0,width,height/2);
    const floor = ctx.createLinearGradient(0,height/2,0,height);
    floor.addColorStop(0,'#0b1220'); floor.addColorStop(1,'#030712');
    ctx.fillStyle = floor; ctx.fillRect(0,height/2,width,height/2);

    const numRays = Math.floor(width * CONFIG.renderResolutionScale);
    const step = width / numRays;
    for (let col = 0; col < numRays; col++) {
      const screenX = (col + 0.5) / numRays * 2 - 1; // -1..1
      const rayDirX = player.dirX + player.planeX * screenX;
      const rayDirY = player.dirY + player.planeY * screenX;

      let mapX = Math.floor(player.x);
      let mapY = Math.floor(player.y);

      const deltaDistX = Math.abs(1 / (rayDirX || 1e-6));
      const deltaDistY = Math.abs(1 / (rayDirY || 1e-6));
      let sideDistX, sideDistY;
      let stepX, stepY;
      if (rayDirX < 0) { stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; }
      else { stepX = 1; sideDistX = (mapX + 1.0 - player.x) * deltaDistX; }
      if (rayDirY < 0) { stepY = -1; sideDistY = (player.y - mapY) * deltaDistY; }
      else { stepY = 1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; }

      let hit = 0; let side = 0; let tile = 0; let doorFrac = 0;
      // DDA
      for (let i=0; i<1024; i++) {
        if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
        else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
        tile = mapAt(mapX, mapY);
        if (isWall(tile)) {
          // Doors may be open (let ray pass proportionally)
          if (isDoor(tile)) {
            const st = doorState(mapX, mapY);
            doorFrac = st.open; // 0 closed -> wall; near 1 open -> nearly passable
            if (doorFrac < 0.98) { hit = 1; break; }
            // Door fully open? pass through and continue DDA
          } else { hit = 1; break; }
        }
      }

      // Distance to wall
      let perpWallDist;
      if (side === 0) perpWallDist = (mapX - player.x + (1 - stepX) / 2) / (rayDirX || 1e-6);
      else perpWallDist = (mapY - player.y + (1 - stepY) / 2) / (rayDirY || 1e-6);
      if (perpWallDist <= 0) perpWallDist = 1e-3;
      zBuffer[Math.floor(col * step)] = perpWallDist;

      // Height of wall slice
      const lineHeight = Math.floor(height / perpWallDist);
      let drawStart = Math.floor(-lineHeight / 2 + height / 2);
      let drawEnd = Math.floor(lineHeight / 2 + height / 2);
      if (drawStart < 0) drawStart = 0; if (drawEnd >= height) drawEnd = height - 1;

      // Texture X coordinate
      let wallX; // exact hit location on wall
      if (side === 0) wallX = player.y + perpWallDist * rayDirY; else wallX = player.x + perpWallDist * rayDirX; wallX -= Math.floor(wallX);
      let texX = Math.floor(wallX * TEX_SIZE);
      if (side === 0 && rayDirX > 0) texX = TEX_SIZE - texX - 1;
      if (side === 1 && rayDirY < 0) texX = TEX_SIZE - texX - 1;

      // Pick texture
      let tex = textures[tile] || textures[1];
      // Darken on Y-side to fake lighting
      const darken = side === 1 ? 0.18 : 0.08;

      // Draw 1px vertical slice scaled to lineHeight
      const drawX = Math.floor(col * step);
      ctx.drawImage(tex, texX, 0, 1, TEX_SIZE, drawX, drawStart, Math.max(1, Math.ceil(step)), drawEnd - drawStart);
      ctx.fillStyle = `rgba(0,0,0,${darken + Math.min(0.5, perpWallDist*0.04)})`;
      ctx.fillRect(drawX, drawStart, Math.max(1, Math.ceil(step)), drawEnd - drawStart);
    }
  }

  // Sprite rendering (enemies, pickups)
  function renderSprites() {
    const width = canvas.width, height = canvas.height;
    const invDet = 1.0 / (player.planeX * player.dirY - player.dirX * player.planeY);
    const sorted = entities.map((e,i)=>({i, d:(e.x-player.x)**2 + (e.y-player.y)**2})).sort((a,b)=>b.d-a.d);
    for (const {i} of sorted) {
      const e = entities[i]; if (e.dead) continue;
      let tex; if (e.type === ENTITY_TYPES.ENEMY) tex = SPR.enemy; else if (e.type === ENTITY_TYPES.AMMO) tex = SPR.ammo; else tex = SPR.medkit;
      const spriteX = e.x - player.x; const spriteY = e.y - player.y;
      const transformX = invDet * (player.dirY * spriteX - player.dirX * spriteY);
      const transformY = invDet * (-player.planeY * spriteX + player.planeX * spriteY);
      if (transformY <= 0.01) continue; // behind camera
      const spriteScreenX = Math.floor((width / 2) * (1 + transformX / transformY));
      const spriteHeight = Math.abs(Math.floor(height / transformY));
      const spriteWidth = spriteHeight;
      const drawStartY = Math.max(0, -spriteHeight/2 + height/2);
      const drawEndY = Math.min(height-1, spriteHeight/2 + height/2);
      let drawStartX = Math.floor(-spriteWidth/2 + spriteScreenX);
      let drawEndX = Math.floor(spriteWidth/2 + spriteScreenX);
      if (drawEndX < 0 || drawStartX >= width) continue;

      drawStartX = Math.max(0, drawStartX); drawEndX = Math.min(width-1, drawEndX);
      for (let stripe = drawStartX; stripe < drawEndX; stripe++) {
        const texX = Math.floor((stripe - (-spriteWidth/2 + spriteScreenX)) * tex.width / spriteWidth);
        if (transformY > 0 && stripe > 0 && stripe < width && transformY < (zBuffer[stripe] || 1e9)) {
          ctx.drawImage(tex, texX, 0, 1, tex.height, stripe, drawStartY, 1, drawEndY - drawStartY);
        }
      }
      // Optional hurt flash
      if (e.hurtTimer > 0 && e.type === ENTITY_TYPES.ENEMY) {
        const alpha = Math.min(0.5, e.hurtTimer);
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.fillRect(drawStartX, drawStartY, drawEndX-drawStartX, drawEndY-drawStartY);
      }
    }
  }

  function renderWeapon() {
    const w = canvas.width, h = canvas.height;
    const weaponW = Math.floor(w * 0.38), weaponH = Math.floor(h * 0.55);
    const x = Math.floor(w/2 - weaponW/2); const y = Math.floor(h - weaponH + 6);
    ctx.drawImage(SPR.weapon, 0, 0, SPR.weapon.width, SPR.weapon.height, x, y, weaponW, weaponH);
    if (muzzleFlashTimer > 0) {
      const s = Math.floor(lerp(w*0.12, w*0.18, Math.random()));
      ctx.globalCompositeOperation = 'screen';
      ctx.drawImage(SPR.flash, w/2 - s/2 + rand(-8,8), h*0.62 + rand(-6,6), s, s);
      ctx.globalCompositeOperation = 'source-over';
    }
  }

  function drawHUD() {
    ui.health.textContent = Math.max(0, Math.floor(player.health));
    ui.ammo.textContent = Math.floor(player.ammo);
    ui.score.textContent = Math.floor(player.score);
  }

  function drawMiniMap() {
    const scale = 6.5;
    gmini.clearRect(0,0,mini.width, mini.height);
    gmini.fillStyle = '#0b1220'; gmini.fillRect(0,0,mini.width, mini.height);
    for (let y=0;y<MAP_H;y++) for (let x=0;x<MAP_W;x++) {
      const t = mapAt(x,y);
      if (t !== 0) {
        gmini.fillStyle = t===4? '#8b6b3c' : t===1? '#b91c1c' : t===2? '#94a3b8' : t===3? '#f59e0b' : '#6b7280';
        gmini.fillRect(x*scale, y*scale, scale-1, scale-1);
      }
    }
    // Player
    gmini.fillStyle = '#22c55e';
    gmini.beginPath(); gmini.arc(player.x*scale, player.y*scale, 2.4, 0, TAU); gmini.fill();
    // Facing
    gmini.strokeStyle = '#22c55e'; gmini.beginPath(); gmini.moveTo(player.x*scale, player.y*scale);
    gmini.lineTo((player.x + player.dirX*0.8)*scale, (player.y + player.dirY*0.8)*scale); gmini.stroke();
  }

  // Physics and interactions
  function tryMove(newX, newY) {
    const radius = 0.22;
    const tiles = [
      mapAt(Math.floor(newX - radius), Math.floor(player.y)),
      mapAt(Math.floor(newX + radius), Math.floor(player.y)),
      mapAt(Math.floor(player.x), Math.floor(newY - radius)),
      mapAt(Math.floor(player.x), Math.floor(newY + radius)),
    ];
    const passable = (t, cx, cy) => {
      if (t === 0) return true;
      if (t === 4) { // door: pass if sufficiently open
        const st = doorState(cx, cy); return st.open > 0.6;
      }
      return false;
    };
    const cx = Math.floor(newX), cy = Math.floor(player.y);
    if (passable(tiles[0], Math.floor(newX - radius), cy) && passable(tiles[1], Math.floor(newX + radius), cy)) player.x = newX;
    const cy2 = Math.floor(newY);
    if (passable(tiles[2], Math.floor(player.x), Math.floor(newY - radius)) && passable(tiles[3], Math.floor(player.x), Math.floor(newY + radius))) player.y = newY;
  }

  function openDoor() {
    const tx = Math.floor(player.x + player.dirX * 0.8);
    const ty = Math.floor(player.y + player.dirY * 0.8);
    if (mapAt(tx,ty) === 4) {
      const st = doorState(tx,ty); st.lastUseTime = nowSec(); sfx.door(); showToast('Door opening');
    }
  }

  function updateDoors(dt) {
    for (const [k, st] of doors) {
      const elapsed = nowSec() - st.lastUseTime;
      if (elapsed < CONFIG.doorOpenTime) st.open = clamp(st.open + dt*0.7, 0, 1);
      else st.open = clamp(st.open - dt*0.7, 0, 1);
    }
  }

  function enemyAI(dt) {
    for (const e of entities) {
      if (e.type !== ENTITY_TYPES.ENEMY || e.dead) continue;
      e.t += dt; e.hurtTimer = Math.max(0, e.hurtTimer - dt);
      const dx = player.x - e.x, dy = player.y - e.y; const dist = Math.hypot(dx,dy);
      // Line of sight simple check using a few steps
      let hasLOS = true; {
        const steps = 10; const stepX = dx/steps, stepY = dy/steps; let cx = e.x, cy = e.y;
        for (let i=0;i<steps;i++) { cx += stepX; cy += stepY; if (isWall(mapAt(Math.floor(cx), Math.floor(cy)))) { hasLOS = false; break; } }
      }
      if (hasLOS && dist < 8) {
        // Chase
        const sp = 1.2;
        const nx = e.x + (dx/dist) * sp * dt;
        const ny = e.y + (dy/dist) * sp * dt;
        if (!isWall(mapAt(Math.floor(nx), Math.floor(e.y)))) e.x = nx;
        if (!isWall(mapAt(Math.floor(e.x), Math.floor(ny)))) e.y = ny;
        // Attack if close
        if (dist < 1.1) {
          player.health -= 10 * dt; if (Math.random()<0.02) sfx.hurt();
          if (player.health <= 0) player.alive = false;
        }
      } else {
        // Wander
        const dir = Math.sin(e.t*0.5 + e.x*1.1 + e.y*0.9);
        const nx = e.x + Math.cos(dir) * 0.5 * dt; const ny = e.y + Math.sin(dir) * 0.5 * dt;
        if (!isWall(mapAt(Math.floor(nx), Math.floor(e.y)))) e.x = nx;
        if (!isWall(mapAt(Math.floor(e.x), Math.floor(ny)))) e.y = ny;
      }
    }
  }

  function interactPickups() {
    for (const e of entities) {
      if (e.dead) continue;
      const dx = e.x - player.x, dy = e.y - player.y; const dist = Math.hypot(dx,dy);
      if (dist < 0.8) {
        if (e.type === ENTITY_TYPES.AMMO) { player.ammo = Math.min(200, player.ammo + 12); e.dead = true; sfx.pickup(); showToast('+ Ammo'); }
        if (e.type === ENTITY_TYPES.MEDKIT) { player.health = Math.min(100, player.health + 25); e.dead = true; sfx.pickup(); showToast('+ Medkit'); }
      }
    }
  }

  function fireWeapon() {
    if (!player.alive) return;
    if (player.fireCooldown > 0) return;
    if (player.ammo <= 0) { showToast('Out of ammo'); return; }
    player.fireCooldown = 0.2; player.ammo -= 1; muzzleFlashTimer = 0.07; sfx.shoot();
    // Hitscan along player dir to nearest enemy
    let hitEntity = null; let bestDist = 1e9;
    for (const e of entities) {
      if (e.type !== ENTITY_TYPES.ENEMY || e.dead) continue;
      // Project enemy center onto ray
      const vx = e.x - player.x, vy = e.y - player.y; const proj = vx * player.dirX + vy * player.dirY; if (proj <= 0) continue;
      const perp = Math.abs(-player.dirY * vx + player.dirX * vy); // distance from ray
      if (perp < 0.4 && proj < bestDist && proj < CONFIG.maxProjectDistance) {
        // Check if wall blocks
        let blocked = false; const steps = Math.ceil(proj * 2);
        for (let i=1;i<=steps;i++) {
          const rx = player.x + player.dirX * (i/2), ry = player.y + player.dirY * (i/2);
          const t = mapAt(Math.floor(rx), Math.floor(ry)); if (isWall(t) && t !== 4) { blocked = true; break; }
        }
        if (!blocked) { hitEntity = e; bestDist = proj; }
      }
    }
    if (hitEntity) {
      hitEntity.health -= 25; hitEntity.hurtTimer = 0.2; sfx.hit();
      if (hitEntity.health <= 0) { hitEntity.dead = true; player.score += 100; showToast('Enemy down +100'); }
    }
  }

  function handleInput(dt) {
    // Rotation
    let rot = 0; if (keys.has('arrowleft')) rot -= 1; if (keys.has('arrowright')) rot += 1;
    if (mouseActive && mouseDeltaX !== 0) { rot += mouseDeltaX * 0.05; mouseDeltaX = 0; }
    const rotAmt = rot * CONFIG.rotSpeed * dt; if (rotAmt !== 0) {
      const cos = Math.cos(rotAmt), sin = Math.sin(rotAmt);
      const oldDirX = player.dirX; player.dirX = player.dirX * cos - player.dirY * sin; player.dirY = oldDirX * sin + player.dirY * cos;
      const oldPlaneX = player.planeX; player.planeX = player.planeX * cos - player.planeY * sin; player.planeY = oldPlaneX * sin + player.planeY * cos;
    }
    // Movement
    let moveX = 0, moveY = 0;
    if (keys.has('w') || keys.has('arrowup')) { moveX += player.dirX; moveY += player.dirY; }
    if (keys.has('s')) { moveX -= player.dirX; moveY -= player.dirY; }
    if (keys.has('a')) { moveX += player.dirY; moveY += -player.dirX; }
    if (keys.has('d')) { moveX += -player.dirY; moveY += player.dirX; }
    const len = Math.hypot(moveX, moveY) || 1; moveX/=len; moveY/=len;
    const speed = (keys.has('shift')? 1.6:1) * (Math.abs(moveX*player.dirX + moveY*player.dirY) > 0.5 ? CONFIG.moveSpeed : CONFIG.strafeSpeed);
    tryMove(player.x + moveX * speed * dt, player.y + moveY * speed * dt);

    if (keys.has('e')) { openDoor(); keys.delete('e'); }
    if (keys.has(' ') || keys.has('enter')) { fireWeapon(); keys.delete(' '); keys.delete('enter'); }
    if (keys.has('p')) { paused = !paused; keys.delete('p'); showToast(paused?'Paused':'Resumed'); }
    if (!player.alive && (keys.has('r'))) { restart(); keys.delete('r'); }
  }

  function restart() {
    player.x = 3.5; player.y = 3.5; player.dirX = 1; player.dirY = 0; player.planeX = 0; player.planeY = Math.tan(deg2rad(CONFIG.fovDegrees)/2);
    player.health = 100; player.ammo = 50; player.score = 0; player.alive = true; player.fireCooldown = 0;
    entities.length = 0; doors.clear();
    spawn(ENTITY_TYPES.ENEMY, 10.5, 10.5);
    spawn(ENTITY_TYPES.ENEMY, 14.5, 12.5);
    spawn(ENTITY_TYPES.ENEMY, 18.2, 17.8);
    spawn(ENTITY_TYPES.AMMO, 5.5, 5.5);
    spawn(ENTITY_TYPES.MEDKIT, 7.2, 5.5);
    spawn(ENTITY_TYPES.ENEMY, 9.5, 20.2);
    spawn(ENTITY_TYPES.AMMO, 12.5, 15.2);
    spawn(ENTITY_TYPES.MEDKIT, 20.5, 16.5);
    showToast('Restarted');
  }

  // Main loop
  let fpsTimer = 0; let fpsCounter = 0; let currentFPS = 0;
  function frame() {
    const t = nowSec(); let dt = t - lastTime; lastTime = t; dt = Math.min(dt, 1/30);
    if (gameStarted && !paused) {
      player.fireCooldown = Math.max(0, player.fireCooldown - dt);
      muzzleFlashTimer = Math.max(0, muzzleFlashTimer - dt);
      handleInput(dt);
      enemyAI(dt);
      interactPickups();
      updateDoors(dt);
      renderWalls();
      renderSprites();
      renderWeapon();
      drawHUD();
      drawMiniMap();
      if (!player.alive) {
        ctx.fillStyle = 'rgba(239,68,68,.25)'; ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.fillStyle = '#fff'; ctx.font = '700 28px system-ui'; ctx.textAlign = 'center';
        ctx.fillText('You died — Press R to restart', canvas.width/2, canvas.height*0.28);
      }
      // FPS
      fpsCounter++; fpsTimer += dt; if (fpsTimer > 0.5) { currentFPS = Math.round(fpsCounter / fpsTimer); ui.fps.textContent = currentFPS; fpsCounter = 0; fpsTimer = 0; }
    }
    requestAnimationFrame(frame);
  }

  // Start hooks
  ui.btnStart.addEventListener('click', () => { ui.overlay.style.display='none'; hookControls(true); sfx.tone(440,0.08,'square',0.15); gameStarted=true; showToast('Good luck!'); });
  ui.btnNoMouse.addEventListener('click', () => { ui.overlay.style.display='none'; hookControls(false); sfx.tone(330,0.08,'square',0.15); gameStarted=true; showToast('Use Arrow keys to turn'); });
  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('mousedown', (e)=>{ if (e.button===0) fireWeapon(); });

  // Resize to device size while keeping internal resolution stable
  function fit() {
    const rect = document.getElementById('gameWrapper').getBoundingClientRect();
    canvas.width = CONFIG.canvasWidth; canvas.height = CONFIG.canvasHeight;
    // CSS scales canvas, content remains crisp with pixelated setting
  }
  window.addEventListener('resize', fit);
  fit();

  requestAnimationFrame(frame);
  </script>
</body>
</html>


